Youtube Link : https://www.youtube.com/watch?v=3xoOkyDnkps&list=PL9fcHFJHtFaYbvOwdxMXih0HSGkhM14Lw&index=5

Documentation Link : https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design

==============================================================================================================================
SOLID is an acronym for the first five object-oriented design (OOD) principles by Robert C. Martin (also known as Uncle Bob).

These principles establish practices that lend to developing software with considerations for maintaining and extending as the project grows. Adopting these practices can also contribute to avoiding code smells, refactoring code, and Agile or Adaptive software development.

SOLID stands for:

S - Single-responsiblity Principle
O - Open-closed Principle
L - Liskov Substitution Principle
I - Interface Segregation Principle
D - Dependency Inversion Principle

=================================================================================================================================
Single-responsibility Principle (SRP) states:

A class should have one and only one reason to change, meaning that a class should have only one job.

For example , suppose in the bank there is only one employee which plays role for manager, cashier, clerk. which broke the rule of Single-responsibility beacuse employee do multi-tasking. In laravel , Every Table have their class which is called Model 

like Model Class -> related to Database (every thing related to Database queries) 
and Controler -> related to logic part 

practical Example : Bill Class -> which will pay all bills like electricity bill , phone bill, water bill etc. 


=================================================================================================================================
Open-Closed Principle
 
Objects or entities should be open for extension but closed for modification.

This means that a class should be extendable without modifying the class itself.

=================================================================================================================================
Liskov Substitution Principle states:

Let q(x) be a property provable about objects of x of type T. Then q(y) should be provable for objects y of type S where S is a subtype of T.

This means that every subclass or derived class should be substitutable for their base or parent class.

=================================================================================================================================
Interface segregation principle states:

A client should never be forced to implement an interface that it doesn’t use, or clients shouldn’t be forced to depend on methods they do not use.

=================================================================================================================================
Dependency inversion principle states:

Entities must depend on abstractions, not on concretions. It states that the high-level module must not depend on the low-level module, but they should depend on abstractions.



=================================================================================================================================
Example
Single responsibility principle

    Class Shapes{
        private $radius;
        
        private $length;
        
        public function getRadius($radius)
        {
            $this->radius = $radius;
        }

        public function getLength($length)
        {
            $this->length = $length;
        }
        public function area(){
            echo "Area of Circle : ". pi()*pow($this->radius,2);
            echo "<br/>";
            echo "Area of Square : ". pow($this->length,2);
        }
        
    }
    $shape = new Shapes();
    $shape->getRadius(25);
    $shape->getLength(30);
    $shape->area();

    suppose some one say that i just need to calculate the area of circle shape not the other shapes so the above class make problem for him. in the above example we are calculating two different areas of two different shapes in a single class which break the rule of single responsibility principle

    #Solution

    we just separate out the square and circle function from each other and put it into a single-single class.

    <?php

        Class Square{
            
            private $length;
            
            public function getLength($length)
            {
                $this->length = $length;
            }
            public function area()
            {
                echo "Area of Square : ". pow($this->length,2);
            }
            
        }

        Class Circle{
            
            private $radius;

            public function getRadius($radius)
            {
                $this->radius = $radius;
            }

            public function area()
            {
                echo "Area of Circle : ". pi()*pow($this->radius,2);
            }
        }


        $square = new Square();
        $circle = new Circle();

        $square->getLength(30);
        $circle->getRadius(25);

        $square->area();
        echo "<br/>";
        $circle->area();

    Note : we could create also areaCalculator Class which only calculate the area of the particlaur Shape. 

    read from here : https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design    

 =================================================================================================================================
Example
Open Closed Principle 

        read from here : https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design

        

        

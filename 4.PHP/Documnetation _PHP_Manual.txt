Introduction 
PHP supports ten primitive types.

	Four scalar types:

		bool
		int
		float (floating-point number, aka double)
		string
	
	Four compound types:

		array
		object
		callable
		iterable
	
	And finally two special types:

		resource
		NULL

	Some references to the type "double" may remain in the manual. Consider double the same as float; the two names exist only for historic reasons.

	The type of a variable is not usually set by the programmer; rather, it is decided at runtime by PHP depending on the context in which that variable is used.

	Note: To check the type and value of an expression, use the var_dump() function.

	To get a human-readable representation of a type for debugging, use the gettype() function. To check for a certain type, do not use gettype(), but rather the is_type functions. Some examples:

	<?php
		$a_bool = TRUE;   // a boolean
		$a_str  = "foo";  // a string
		$a_str2 = 'foo';  // a string
		$an_int = 12;     // an integer

		echo gettype($a_bool); // prints out:  boolean
		echo gettype($a_str);  // prints out:  string

		// If this is an integer, increment it by four
		if (is_int($an_int)) {
		    $an_int += 4;
		}

		// If $a_bool is a string, print it out
		// (does not print out anything)
		if (is_string($a_bool)) {
		    echo "String: $a_bool";
		}
	?>
	To forcibly convert a variable to a certain type, either 'cast' the variable or use the 'settype()' function on it.

	Note : Null will be cast to the empty string, i.e. the key null will actually be stored under "".


	Note : The unset() function allows removing keys from an array. Be aware that the array will not be reindexed. If a true "remove and shift" behavior is desired, the array can be reindexed using the array_values() function.
=====================================================================================================================================
Converting to object 
			If an object is converted to an object, it is not modified. If a value of any other type is converted to an object, a new instance of the stdClass built-in class is created. If the value was null, the new instance will be empty. An array converts to an object with properties named by keys and corresponding values. Note that in this case before PHP 7.2.0 numeric keys have been inaccessible unless iterated.

			<?php $genericObject = new stdClass(); ?>

====================================================================================================================================
Resources 
	A resource is a special variable, holding a reference to an external resource. Resources are created and used by special functions. 		
	As resource variables hold special handles to opened files, database connections, image canvas areas and the like, converting to a resource makes no sense.

	Thanks to the reference-counting system being part of Zend Engine, a resource with no more references to it is detected automatically, and it is freed by the garbage collector. For this reason, it is rarely necessary to free the memory manually.
==================================================================================================================================
NULL 
The special null value represents a variable with no value. null is the only possible value of type null.

A variable is considered to be null if:

it has been assigned the constant null.

it has not been set to any value yet.

it has been unset().

<?php
$var = NULL;       
?>
See also the functions is_null() and unset().

==================================================================================================================================
Callbacks / Callables

1. A callback function is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or action. ... A good example is the callback functions executed inside a . then() block chained onto the end of a promise after that promise fulfills or rejects.

2. A callback function (often referred to as just "callback") is a function which is passed as an argument into another function.

3. Any existing function can be used as a callback function. To use a function as a callback function, pass a string containing the name of the function as the argument of another function:	

Pass a callback to PHP's array_map() function to calculate the length of every string in an array:

<?php
function my_callback($item) {
  return strlen($item);
}

$strings = ["apple", "orange", "banana", "coconut"];
$lengths = array_map("my_callback", $strings);
print_r($lengths);
?>
		or 

function call_user_func(){
	code here ....
}

function my_callback_function(){
	code here .....
}

call_user_func('my_callback_function');
==========================================================================================================================

$a = 'abc';
$$a = 123;

echo $a;			// abc 
echo "<br/>";
echo $$a;			// 123
echo "<br/>";		
echo $abc;			// 123


or 

echo "$a ${$a}";		// abc 123	



//You can even add more Dollar Signs

  $Bar = "a";
  $Foo = "Bar";
  $World = "Foo";
  $Hello = "World";
  $a = "Hello";

  echo $a; //Returns Hello
  echo $$a; //Returns World
  echo $$$a; //Returns Foo
  echo $$$$a; //Returns Bar
  echo $$$$$a; //Returns a

  echo $$$$$$a; //Returns Hello
  echo $$$$$$$a; //Returns World

  //... and so on ...// 

============================================================================================================================================
##CONSTANTS and PHP Class Definitions

Using "define('MY_VAR', 'default value')" INSIDE a class definition does not work as expected. You have to use the PHP keyword 'const' and initialize it with a scalar value -- boolean, int, float, string (or array in PHP 5.6+) -- right away.

<?php

define('MIN_VALUE', '0.0');   // RIGHT - Works OUTSIDE of a class definition.
define('MAX_VALUE', '1.0');   // RIGHT - Works OUTSIDE of a class definition.

//const MIN_VALUE = 0.0;         RIGHT - Works both INSIDE and OUTSIDE of a class definition.
//const MAX_VALUE = 1.0;         RIGHT - Works both INSIDE and OUTSIDE of a class definition.

class Constants
{
  //define('MIN_VALUE', '0.0');  WRONG - Works OUTSIDE of a class definition.
  //define('MAX_VALUE', '1.0');  WRONG - Works OUTSIDE of a class definition.

  const MIN_VALUE = 0.0;      // RIGHT - Works INSIDE of a class definition.
  const MAX_VALUE = 1.0;      // RIGHT - Works INSIDE of a class definition.

  public static function getMinValue()
  {
    return self::MIN_VALUE;
  }

  public static function getMaxValue()
  {
    return self::MAX_VALUE;
  }
}

?>

#Example 1:
You can access these constants DIRECTLY like so:
* type the class name exactly.
* type two (2) colons.
* type the const name exactly.

#Example 2:
Because our class definition provides two (2) static functions, you can also access them like so:
* type the class name exactly.
* type two (2) colons.
* type the function name exactly (with the parentheses).

<?php

#Example 1:
$min = Constants::MIN_VALUE;
$max = Constants::MAX_VALUE;

#Example 2:
$min = Constants::getMinValue();
$max = Constants::getMaxValue();

?>

Once class constants are declared AND initialized, they cannot be set to different values -- that is why there are no setMinValue() and setMaxValue() functions in the class definition -- which means they are READ-ONLY and STATIC (shared by all instances of the class).

Note : When using the const keyword, only scalar (bool, int, float and string) expressions and constant arrays containing only scalar expressions are accepted. It is possible to define constants as a resource, but it should be avoided, as it can cause unexpected results.

<?php
	// Simple scalar value
	const CONSTANT = 'Hello World';

	echo CONSTANT;

	// Scalar expression
	const ANOTHER_CONST = CONSTANT.'; Goodbye World';
	echo ANOTHER_CONST;

	const ANIMALS = array('dog', 'cat', 'bird');
	echo ANIMALS[1]; // outputs "cat"

	// Constant arrays
	define('ANIMALS', array(
		'dog',
		'cat',
		'bird'
	));
	echo ANIMALS[1]; // outputs "cat"
?>

There are nine magical constants that change depending on where they are used. For example, the value of __LINE__ depends on the line that it's used on in your script. All these "magical" constants are resolved at compile time, unlike regular constants, which are resolved at runtime. These special constants are case-insensitive and are as follows:

PHP's magic constants
Name	Description
__LINE__	The current line number of the file.
__FILE__	The full path and filename of the file with symlinks resolved. If used inside an include, the name of the included file is returned.
__DIR__	The directory of the file. If used inside an include, the directory of the included file is returned. This is equivalent to dirname(__FILE__). This directory name does not have a trailing slash unless it is the root directory.
__FUNCTION__	The function name, or {closure} for anonymous functions.
__CLASS__	The class name. The class name includes the namespace it was declared in (e.g. Foo\Bar). When used in a trait method, __CLASS__ is the name of the class the trait is used in.
__TRAIT__	The trait name. The trait name includes the namespace it was declared in (e.g. Foo\Bar).
__METHOD__	The class method name.
__NAMESPACE__	The name of the current namespace.
ClassName::class	The fully qualified class name.
See Also
::class
get_class()
get_object_vars()
file_exists()
function_exists()





Note 
	1. Expressions are the most important building blocks of PHP. In PHP, almost anything you write is an expression. The simplest yet most accurate way to define an expression is "anything that has a value".
			The most basic forms of expressions are constants and variables.
	
	2.  (scalar values are values that you can't 'break' into smaller pieces, unlike arrays, for instance).
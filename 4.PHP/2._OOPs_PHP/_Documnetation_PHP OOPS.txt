#Topic 
1. Class and Objects
2. Access Modifiers
3. Inheritence
4. Over Ridding
5. Abstract Class 
6. Interfaces (multiple inheritance systme)
7. Static Members (properties and methods)
8. Late Static Binding 
9. Traits (single function use in various)
10. Type hinting 
11. Namespace
12. Method Chaining 
13. Magic Methods : calls automatically when object is created and its colur is blue 
		a. Constructor 							: for creating connection 
		b. Destructor 							: use for closing Connection database 
		c. Autoload/sp_autoload_register		: load that class that which object is calling 
		d. get & Set							: Check for variables and Set Private value 	
		e. call     							: Check for methods 
		f. callStatic 							: Check for private static methods 
		g. isset 								: check  variable set or not 
		h. unset 								: to unset variable
		i. tostring 							: call when we print object as a string 
		j. sleep 								: convert object into array
		k. wakeUp 								: convert array to object
		l. Clone 								: Copy of functions and variables of one object to another object (same as pass by value)
		m. invoke 								: use object as function
		
14. Magic Constants : 
		a. __LINE__		: print line number 
		b. __FILE__		: return absolut Path of file 
		c. __DIR__		: Absolute Directory Path
		d. __FUNCTION__	: return Function name  , if name space is used then return along with name sapce
		e. __CLASS__	: return Class Name 	, if name space is used then return along with name sapce
		f. __METHOD__	: return Class method name , if name space is used then return along with name sapce
		g. __NAMESPACE__: return namespace name  
		h. __TRAIT__	: return trait name

15. Conditional Function 
		a. class_exists()				: return if class exist
		b. interface_exists()			: return if interface exist
		c. method_exists()				: return if method exist
		d. trait_exists()				: reurn if trait exist
		e. property_exists()			: return property
		f. is_a()						: return object of that class
		g. is_subclass_of() 			: return oject of the parent class

16. get Function 
		a. get_class()					: return the class name 
		b. get_parent_class()			: retnrn the parent Class name 
		c. get_class_method()			: return all the functions names 
		d. get_class_vars()				: return all the variables names with values
		e. get_object_vars()			: return all the variables names with values
		f. get_called_class()			: return name of class from where it is call   
		g. get_declared_classes()		: return all the classes which is declared on the file 
		h. get_declared_interfaces()	: return all the interface names which is declared in the file
		i. get_declared_traits()		: return all the traits name which is declared in the file
		j. class_alias()				: set another name of the class 

17. Final Key word		



=============================================================================================================================================
#OOPS

1. OOPS is about creating classes and objects. Classes serves as a templates and multiple objects can be created using a classes.

2. what are classes and objects : Classes are templates for creating objects. Eg : if car is a class then maruti suzuki alto and maruti swift are two objects 

3. why OOPs : OOPs make it easy to keep the code DRY?..... DRY - Do not repeat yourself- the code written by the program should be reuseable.


Spose in class there are 30 students, now teacher have to show numbers of each students so he can show in two way 
1. make a Template for each student to show marks : called Procedural Programming
2. make a single template and use that single template to show marks by calling functions : Called OOPs programming 


Syntax
------
	Class player{
		public $name;											// properties (variable of current class)
		public $speed = 5;										// properties (variable of current class)
				
				OR

		pulbic $name,$speed=5;									// another method	

		function set_name($name)
		{							
			$this->name = $name;								here $this->name means $player1->name means object its self
		} 
	}

	Note : $this->name means  current class variable accessing in function and then assiging value from paramaters of functions

	$player1= new Player();											// creating object of the class

	$player1->set_name('Deepinder Singh');							// calling Function and passing paramaters  
		
	echo $player1->get_name();										// calling function and getting return value 

	echo $player1->speed;											// accessing direct variable;

==============================================================================================================================================
#Tips in OOPS progrming 

1. Concept of Object 

	1.in simple words object in which we store the infromartion in it 
	2.We create the object from Class 
	3.The process of creating an object is also known as instantiation 
	4.the object is an instance of the class means an example of class 

2. variable 
	POP variable is $balance ;
	OOP variable is $this->balance and we have to mention access specifiers in front of the variable and this variable is called Pseudo Variable 


	if we create to many objects then momery block will be different for every objects while have there variable values and functions 

3. arrguments (function variables and parameters) have local scope example 

	class student{
		private $name, $address,$contactno;

		public function getData($sname=null,$sadd=null,$scon=null){
			global $name;
			$name=$sname;
			$this->address=$sadd;
			$this->contactno=$scon;
		}
		public function showData(){
			global $name;
			return $name;
		}
	}

	$studentObject=new student();


	$studentObject->getData('Deepinder Singh','India','9915099247');
	echo $studentObject->showData();


4. we can pass the class name like this 
	fxn('classname') or fxn($object) or fxn($this) or fxn(new classname) or fxn(__CLASSNAME__)

5. Object in the class become $this and outside the Class its name of variable 	

6. the function which is used to set the values of the variable is Called 'Setter Function' and the function which is used to retrived the values from the variables are called 'Getter Function'. 
=========================================================================================================================================
#concept of $this ($this Pseudo Variable) {$this means current object of the class which is accessing the things in class }

	1. Example 1

		#Code 
			class Student{

				private $name = "Deepnder Singh";

			}
			$obj = new Student();

			print_r($obj);

		#Output
			
			Student Object ( [name:Student:private] => Deepnder Singh )

			classname, we are printing object ([variable name: ClassName : access Modifier] => value)

	2. Exmaple 2

		#Code 	

			class Student{

				private $name ;

				public function setName($name){
					$this->name= $name;
				}
				public function getName(){
					print_r($this);
				}

			}
			$obj1 = new Student();
			$obj2 = new Student();

			$obj1->setName('Deepinder Singh');
			$obj2->setName('Simranjeet Kaur');


			echo "<pre>";
			$obj1->getName();
			$obj2->getName();	


		#Output

			Student Object
			(
				[name:Student:private] => Deepinder Singh
			)
			Student Object
			(
				[name:Student:private] => Simranjeet Kaur
			)
			
	1. Means every object have there own values and properties
	2. when Object is created a momery block is created in Ram  which store variable and functions.... practially the object we created it will point that momery block and also when script is executed whole memory dealocate automatcially by PHP when the scripte execution ends. in other languages memory dealocation process done manually. 



==============================================================================================================================================
# __construct() 

	1. It allows you to initilization objects. It is the code which is executed whenever a new object is intantiated 
	2. If you create a __construct() function, PHP will automatically call this function when you create an object from a class.
	
	
	class Employee{
	
		function __construct(){									// without arguments 
			echo "This is my construct for Employee";
		}

		function __construct($name,$salary)						// with arguments 
		{				
			$this->name=$name;
			$this->salary=$salary;
		}	

		function Employee(){									//this is old constructor but it is deprecated
			echo "Old Constructor";								
		}
	}	

	$deep=new Employee();



============================================================================================================================================
#__Destruct() 

	1. A destructor is called when the object is destructed or the script is stopped or exited.
	2. If you create a __destruct() function, PHP will automatically call this function at the end of the script. : eg we can place here all close connection queries ;(means it work only once at the end of the script)

	class Employee{

		function __destruct(){												// it never received any arguments
			echo "</br> this is destruct $this->name : $this->salary";
		}
	}	

===========================================================================================================================================
#Access Modifiers
	
	1. Properties and methods can have access modifiers which control where they can be accessed.
	2. There are three access modifiers:

		a. public - the property or method can be accessed from everywhere. This is default
		b. protected - the property or method can be accessed within the class and by classes derived from that class
		c. private - the property or method can ONLY be accessed within the class

==========================================================================================================================================
#Encapsulation 

	1. Encapsulation is a concept where we encapsulate all the data and member functions together to form an object.
	2. Wrapping up data member and method together into a single unit is called Encapsulation.
	3. Encapsulation also allows a class to change its internal implementation without hurting the overall functioning of the system.
	4. Binding the data with the code that manipulates it.
	5. It keeps the data and the code safe from external interference.

============================================================================================================================================
#Inheritance 

Inheritance in OOP = When a class derives from another class.

The child class will inherit all the public and protected properties and methods from the parent class. In addition, it can have its own properties and methods.

function cannot be inherit in POP so we have to write whole codes with some additon codes , OOPs concept remove this problem by inheritance 

An inherited class is defined by using the extends keyword.

<?php
class Fruit {
  public $name;
  public $color;
  public function __construct($name, $color) {
    $this->name = $name;
    $this->color = $color;
  }
  public function intro() {
    echo "The fruit is {$this->name} and the color is {$this->color}.";
  }
}

// Strawberry is inherited from Fruit
class Strawberry extends Fruit {
  public function message() {
    echo "Am I a fruit or a berry? ";
  }
}
$strawberry = new Strawberry("Strawberry", "red");
$strawberry->message();
$strawberry->intro();
?>


Note: Check Example of Access specifiers and Inheritence : 04_access_specifiers_and_inheritence

note : function __constructor(){
			parent :: __constructor();
		}



======================================================= Overloading and Over Ridding =========================================================================

Overloading 
------------
1. Function overloading or method overloading is a feature that allows creating several methods with the same name which differ from each other in the type of the input parameters. It is simply defined as the ability of one function to perform different tasks. For example, doTask() and doTask(object O) are overloaded methods. To call the latter, an object must be passed as a parameter, whereas the former does not require a parameter, and is called with an empty parameter field. It is a form of static polymorphism which .The decision to call an implementation or another is taken at coding time. 

2. This is erroneous  since php will say you have declared this method twice . Other languages says its fine and calls it static polymorphic i.e method overloading. You have to use PHP's magic methods to achieve method overloading in PHP.

<?php 
	class overLoad{												// this program produce error 
		public $area;

		public function area($length=null){
			$this->area=$length*$length;
			return $this->area;
		}
		public function area($length=null,$breadth=null){
			$this->area=$length*$breadth;
			return $this->area;
		}
	}

	$areaObject=new overLoad();

	echo $areaObjecte->area(4);;
?>

Over Ridding
------------
Function Overriding: Function overriding is same as other OOPs programming languages. In function overriding, both parent and child classes should have same function name with and number of arguments. It is used to replace parent method in child class. The purpose of overriding is to change the behavior of parent class method. The two methods with the same name and same parameter is called overriding.

<?php 
class classA{
	
	public function get(){
		echo "Hello world";
	}
}

class classB extends classA{

	public function get(){
		echo "Hello Boo BOO";
	}
}

$classBobject=new classB();

$classBobject->get();
?>


================================ Constant =================================================

Constants cannot be changed once it is declared.

Class constants can be useful if you need to define some constant data within a class.

A class constant is declared inside a class with the const keyword.

Class constants are case-sensitive. However, it is recommended to name the constants in all uppercase letters.

We can access a constant from outside the class by using the class name followed by the scope resolution operator (::) followed by the constant name, like here:

Or, we can access a constant from inside the class by using the self keyword followed by the scope resolution operator (::) followed by the constant name, like here:


class Circle{

	const PI=3.14;									// declaring contant variable 

	private $area;
	
	public function area($radius){
		$this->area = self::PI * $radius * $radius;				// accessing constant variable using Self
		return $this->area;
	}
}

$circleObject= new Circle();

echo $circleObject::PI;										// accessing variable using object 

echo "<br/>";
	
echo Circle::PI;						// accessing variable using Class name and not a good methos 

echo "<br/>";

echo $circleObject->area(10);


===================================================================== Abstract Class ==========================================================================

1. we use abstract classes when we want to commit the programmer to write a certian class method, but we are only sure about the name of the method, and not the details of how is should be write 

2. An abstarct class is a class that has at least on abstract method 

3. Abstarct methods can only have names and arguments and no other code. thus we cannot create objects out of abstract classes. Insted we need to create child classes that add the code into the bodies of the month and use these child classes to create objects 

4. Classes extending an abstract class must implement all of the abstract methods defined in the abstract class.

program written in file 
=================================================================== Inheritencae ==========================================================================
Inheritance
It is a concept of accessing the features of one class from another class. If we inherit the class features into another class, we can access both class properties. We can extends the features of a class by using 'extends' keyword.

1. It supports the concept of hierarchical classification.
2. Inheritance has three types, single, multiple and multilevel Inheritance.
3. PHP supports only single inheritance, where only one class can be derived from single parent class.
4. We can simulate multiple inheritance by using interfaces.


==================================================================== Interface Class ==========================================================================
1. An interface is similar to a class except that it cannot contain code.
2. An interface can define method names and arguments, but not the contents of the methods.
3. Any classes implementing an interface must implement all methods defined by the interface.
4. A class can implement multiple interfaces.
5. An interface is declared using the "interface" keyword.
6. Interfaces can't maintain Non-abstract methods.





1. when we inherit one or more class in a single class then we use interface (basically inherit multiple classes in single class)

2. Interfaces make it easy to use a variety of different classes in the same way.
	concept => When one or more classes use the same interface, it is referred to as "polymorphism".

3. Interfaces allow you to specify what methods a class should implement.

Interfaces are declared with the interface keyword:
	
interface InterfaceName {
  public function someMethod1();
  public function someMethod2($name, $color);
  public function someMethod3() : string;
}  


================
PHP - Interfaces vs. Abstract Classes

Interface are similar to abstract classes. The difference between interfaces and abstract classes are:

1. Interfaces cannot have properties, while abstract classes can
2. All interface methods must be public, while abstract class methods is public or protected
3. All methods in an interface are abstract, so they cannot be implemented in code and the abstract keyword is not necessary
4. Classes can implement an interface while inheriting from another class at the same time
=======================

To implement an interface, a class must use the implements keyword.

A class that implements an interface must implement all of the interface's methods.

interface a {
  public function hello();
}
interface b {
  public function hi();
  public function bye();
}

class Cat implements a,c {
  public function hello() {

  }
  public function hi() {

  }
  public function bye() {

  }
}

$animal = new Cat();
$animal->hello();

program written in file 

=====================================================================PHP Namespaces =============================================================================
Namespaces are qualifiers that solve two different problems:

1.They allow for better organization by grouping classes that work together to perform a task
2.They allow the same name to be used for more than one class


For example, you may have a set of classes which describe an HTML table, such as Table, Row and Cell while also having another set of classes to describe furniture, such as Table, Chair and Bed. Namespaces can be used to organize the classes into two different groups while also preventing the two classes Table and Table from being mixed up.


In computer prorgamming name is feature to segregate your code to prevent the clashes in the name of your variables, constants. procedural methods and classes. Name spaces in the computer programming is same as directoty bifurcation in the file system where the file with the same can exists but in two seperate directories for folders.

with a large number of audience, it is a misconception that namespace is only part of object oriented programming where it can be used for classes but this is not true. You can use the namespace is procedural programming as well. You can use namespace in the procedural to club your code to prvent from clashes.  


Namespaces are declared at the beginning of a file using the namespace keyword: 

===================================================================== Traits =================================================================================

Traits are used to declare methods that can be used in multiple classes (means use to create single function in various classes by extending)


PHP only supports single inheritance: a child class can inherit only from one single parent.

So, what if a class needs to inherit multiple behaviors? OOP traits solve this problem.

Traits are used to declare methods that can be used in multiple classes. Traits can have methods and abstract methods that can be used in multiple classes, and the methods can have any access modifier (public, private, or protected).

Traits are declared with the trait keyword:

program written in file

=================================================================== Static Methods/Memebers ====================================================================
 

1. Static methods can be called directly - without creating an instance of the class first. 

2. Static methods are declared with the static keyword:

3. We use self:: insted of $this-> beacuse here we are not creating Objects 

4. To access a static method use the class name, double colon (::), and the method name:

5. program wriitten in file

6. Late static bending -> program is witten in program

7. when we declare static variables and its values then it will share by all the objects of class. Thus static variables will be assigned memory once rather assigning it to each and every object.

#program of static 
<?php

class staticClass{

	public static $name="Deepinder Singh";

	public static function setName(){
		self::$name="Simranjeetkaur";
	}
	 
}

echo staticClass::$name;

staticClass::setName();

echo staticClass::$name;

?>



A class can have both static and non-static methods. A static method can be accessed from a method in the same class using the self keyword and double colon (::):

<?php
class greeting {
  public static function welcome() {
    echo "Hello World!";
  }

  public function __construct() {
    self::welcome();
  }
}

new greeting();
?>



Static methods can also be called from methods in other classes. To do this, the static method should be public:

<?php
class greeting {
  public static function welcome() {
    echo "Hello World!";
  }
}

class SomeOtherClass {
  public function message() {
    greeting::welcome();
  }
}
?>



To call a static method from a child class, use the parent keyword inside the child class. Here, the static method can be public or protected.

<?php
class domain {
  protected static function getWebsiteName() {
    return "W3Schools.com";
  }
}

class domainW3 extends domain {
  public $websiteName;
  public function __construct() {
    $this->websiteName = parent::getWebsiteName();
  }
}

$domainW3 = new domainW3;
echo $domainW3 -> websiteName;
?>
======================================================================= Type Hinting ========================================================================
In simple word, type hinting means providing hints to function to only accept the given data type.
In technical word we can say that Type Hinting is method by which we can force function to accept the desired data type.
In PHP, we can use type hinting for Object, Array and callable data type.

program written in program 
 

 ==================================================================== final Key word ========================================================================
Final Keyword
1. In PHP, Final keyword is applicable to only class and class methods. We cannot declare as Final in PHP.
2. So if we declare class method as a Final then that method cannot be override by the child class.
3. Same as method if we declare class as a Final then that class cannot be extended any more.


<?php  
      
    class base  
    {  
        final public function dis1()  							// final key word for function 
        {  
            echo "Base class..";  
        }     
    }  
    class derived extends base  
    {  
        public function dis1()  
        {  
            echo "derived class";  
        }  
    }  
    $obj = new derived();  
    $obj->dis1();  
  
?>  

======================================================================== Concrete class ==========================================================
concrete is opposite of abstract class whihc have complete implementation of function
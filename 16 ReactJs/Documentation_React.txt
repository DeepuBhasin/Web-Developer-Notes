1. installing : npx create-react-app my-reacte-app

2. import things always import

    import React from 'react';
    import ReactDOM from 'react-dom/client';

=================================================================================================================================
#Render Method 

    The render() method is the only required method in a class component. it examined this.props and this.state

    it returns one of the following types 

        1. React elements : These are created via JSX (Not Required)

    Note : The Render() function should be pure, meaning that it does not modify component state, it returns the same result each time it's invoked and it does not directly interact with the browser.    

=================================================================================================================================
#Render Element 

    you can create a react element using React.createElement() method but there is a easy way to create element via JSX 

    React.createElement("h1",null,"Hello World");

    using jsx : <h1> Hello World </h1>

=================================================================================================================================
#ReactDOM.render(element,DOMnode)

    ReactDOM.render(element,DOMnode) - it takes a React element and render it to a DOM node.


=================================================================================================================================
#React Fragment

    Fragment is used to group a list of children without adding extra nodes to the DOM 

    1. <React.Fragment></React.Fragment>
    2. <></>
    3. <Fragment></Fragment>                import {Fragment} from 'react' 

=================================================================================================================================
#Functional vs Class Component 

    Use Functional components if you are writing a presntational component which doesn't have its own state or need to access a life cycle hook. You cannot use setState() in your component beacuse Functional components are plain Javascript functions. 

    Use class Component if you need state or need a access lifescycle hook beacuse all lifescycle hooks are coming from the the React.component which you extends from in class component.

=================================================================================================================================
#Javascript XML (JSX)

    1. JSX stands for Javascript XML. it is syntax extension to Javascript
    2. JSX is a preprocessor step that adds XML syntax to Javascript
    
    3. JSX produces React 'elements'. It is possible to create element without JSX but JSX makes react a lot more elegant.
    4. It is recommended to use JSX with react to describe what the UI should look like.
    5. JSX is easier to read and write. Babel Transform these Expressions into a actual Javascript Code.
    6. It also allows React the Show more useful error and warning messages. 

#Javascript Expressions in JSX

    we can put any valid Javascript Expression inside the curly barces in jsx. You can pass any Javascript Expression as chiildren, by enclosing it within {}

    {10 + 20}
    {name}
    {show()}
    {username.firstname}


#specifying Attributes with JSX

    1. class            : className 
    2. for              : htmlFor


    <h1 className={ac.tab}>Hello </h1>

=================================================================================================================================
#Props (Props are Read Only)

    1. When React sees an element respresenting a user-defined component, it passes JSX Attributes to this component as a single object. we call this object "props";

    function Students(props){
        return (
            <div>
                <h1> Hello, {props.name}</h1>
                <h1> Your Role, {props.roll}</h1>
            </div>       
        )
    }

    <Students name="Deepinder" roll ="101" />

    2. Whether you declare a component as a function or a class, it must never modify its own props. All React Components must act like pure functions with respect to their props 

    Pure Function
    ============= 
        function sum(a,b){
            return a+b;
        }

    Im-Pure Function
    ============= 
        function withdraw(account,amount){
            account.total -=amount;
        }

=================================================================================================================================
#Props TypeChecking 

    npm install prop-types 

    import pt from 'prop-type'


    Students.propTypes = {
        name : pt.string.isRequired
    }

     Students.defaultProps = {
        name : 'default name'
    }

=================================================================================================================================
#Props.chiildren

    to print Html Data 

    <Students>Hello world</Students>

    {prop.chiildren}


=================================================================================================================================
#State 

    State is similar to props, but private and fully controlled by the component. We can create state only n class component. It is possible to update the state/modify the state 

        There are two way to initialize state in React Component    
        1. directly inside class 
        2. Inside the constructor
        


        directly
        ========

            class App extends Component{
            state ={
                firstName : 'Deepinder',
                lastName : 'Singh'
            }

                render(){
                    return (
                    <>
                    <h1>{this.state.firstName}</h1>
                    <h1>{this.state.lastName}</h1>
                    </>
                    )
                }
            }


        inside constructor
        ==================

        1. When the component class is created, the constructor is the first method called, so it's the right place to add state.
        2. When we write a constructor, make sure to call the parent class constructor by super(props)
        3. When you call super with props. React will make props available across the component through this.props


        import React,{ Component } from "react";

        class App extends Component{
        constructor(props)
        {
            super(props);
            this.state = {
            firstName : 'Deepinder',
            lastName : 'Singh'
            roll : this.props.roll
            }
        
        }

        render(){
            return (
            <>
            <h1>{this.state.firstName}</h1>
            <h1>{this.state.lastName}</h1>
            </>
            )
        }
        }

        export default App;

=================================================================================================================================
#Event Handling 

    Handling events with React elements is very similar to handling events on DOM elements. There are some syntatic Differenec 
    1. React events are named using camalCase, rather than lowercase 
    2. with JSX you pass a function as the event handler, rather than a string 

    InHtml
    ======
        <button onclick="handleclick()">Click Me </button>


    In React 
    ========
        <button onClick={handleclick}>Click Me </button>            // Function Component
        <button onClick={this.handleclick}>Click Me </button>       // Class Component
    


    note : 
        1.  handler=()=>{
                console.log(this);
            }

        2. constructor (props){
                this.handler = this.handler.bind(this)
            } 
        3. <button onClick={()=>{console.log(this);}}>Click ME</button>       


=================================================================================================================================
#constructor()

    The constructor for a React Component is called before it is mounted 

    When implementing the constructor for a React.Component subclass you should call super(props) before any other statement. Otherwise, this.props will be undefined in the constructor, which can lead to bugs. 

    React constructor are only used for two purposes : 

        1. initializing Local state by assigining an object to this.state 
        2. Binding event handler methods to an instance 

=================================================================================================================================
#Hooks

    1. Hooks are function that let you "hook into" React state and lifescycle features from function component
    2. Hooks allow you to use React without classes. it means you can use state and other React features without a class 
    3. React Provides a few built-in Hooks like useState, useEffects etc 
    4. Hooks are a new addition in React 16.8

    When use Hooks 
    ==============

    if you write a function component and realize you need to add some state to it. 

=================================================================================================================================
#Rules of Hooks 

    1. Only call hooks at the top level - We should not call Hooks inside loops, conditions or nested functions. Instead, always use hooks at the top level of your react function 
    2. Only call hooks from react functions  - we should not call hooks from regular javascript functions. Instead, call hooks from react function components or call hooks from custom hooks.
    3. React relies on the order in which hooks are called. 
    4. Hooks don't work inside classes.

=================================================================================================================================
#usestate Hook 

    useState() - useState is a Hook that allows you add React state to function components. We call it inside a function component to add some local state to it. useState returns a pair - the current state value and a function that lets you update it. React will Preserve this state between re-render. 

    You can call this function from an event handler or somewhere else.


=================================================================================================================================
#useEffects 

    useEffect is hook for encapsulating code that has 'side effects', if you are familiar with react class lifecycle methods, you can think of useEffect Hook as componentDidMount, ComponentDidUpdate, and ComponentWillUnmount combined. 

    1. useEffect(function)
    2. useEffect(function,Array)

        a. The function pssed to useEffect will run after the render is commited to the screen 
        b. Second argument to useEffect that is the array of values that the effect depends on. 

#what does useEffect do ?

    By using this Hook, you tell react that your componet nneds to do something after render. React will remeber the function you passed and call it later after performing the DOM updates. In this effect, we set the document title, we could also perform data fetching or call some other imperative API.

#Why is useEffect called inside a Component?
    Placing useEffect inside the component lets us access the state variable or any props right from the effect 

#Does useEffect run after every Render 
    Yes! by default, it runs both after the first render and after every update. 


=================================================================================================================================
#Creating custom Hook 

    A custom Hook is a javscript function whose name starts with "use" and that my call other hooks 

    ex : function useSomething(){
        return 
    }

    const data = useSomething();


    Students.js
    ===========
    import { useState } from "react";

    function useCustomeCounter (){
        let  [count,setCount] = useState(0);
        const handleIncrement = () => {
            setCount(count+ 1);
        }

        return {
            count,
            handleIncrement
        }
    }

    export default  useCustomeCounter;


    App.js
    ======

    import React from "react";
    import useCustomeCounter from './Student.js';


    function App(){
    let {count,handleIncrement} = useCustomeCounter();
    return (
           <div>
            <h1>Count up: {count}</h1>
            <button onClick={()=>handleIncrement()}>Click me</button>
            </div>
        )
    }
    export default App;

=================================================================================================================================
#conditional Rendering
    
    1. conditional Rendering in react works the same way conditions work in javascript
    2. Use javascript operators like if or the conditional (ternary) operator to create elements respresenting the current state, the let React update UI to match them.
    3. if and if-else statement don't work inside JSX. This is beacuse JSX in just syntatic sugar for function calls and object construction. 

    <div id={if(condition){'msg'}}>Hello</div>

    React.createElement("div",{id:if(condition){'msg'}},'Hello');

#inline if with Logical && operator

    you may embed any Expression in jsx by wrapping them in curly braces. This includes the javascript logical && operator

=================================================================================================================================
#Iterating using map() Method
    
    React use map() method for Iterating items

=================================================================================================================================
#Key 

    1. A "Key" is a special string Attribute you need to include when creating lists of elements 
    2. Key help React identify which item have changed, are added or are removed 
    3. keys should be given to the element inside the array to give the elements a stable identify
    4. The best way to pick a key is to use a string that uniquely identifies a list item among its sibling 
    5. Most often you would use Id's from your data as keys 
    6. Keys used within arrays should be unique among their siblings . However they don't need to be globally unique. We can use the same keys when we produce two different arrays.
    7. Keys serve as a hint to react but they don't get passed to your components 
    8. if you need the same value in your component, pass it explicitly as a prop with a different name. 

=================================================================================================================================
#Inline Stylesheet 

    1. 'style' is most often used in React applications to add dynamically-computed styles at render time. 
    2. The 'style' attribute accept a javscript object with camalCase Properties rather than a CSS string. This is consistent with the DOM style javascript property, is more efficient, and prevents XSS security holes.
    3. CSS Classes are generally better for performance than inline styles
    

    const btnstyle = {
        color : 'blue',
        backgroundColor : 'orange'
    };

    <button style={btnstyle}>button</button>

=================================================================================================================================
#Forms 

    1. HTML form elemnts work a little bit differently from the other DOM elements in React, beacuse form elemnts naturally keep some internal state.
    2. in Html, form elements such as <input>, <textarea>, and <select> typically maintain their own state and update it based on user input. In React, mutable (changeable) state is typically kept in the state property of components and only update with setState().
    
    a. controlled component
    b. Uncontrolled component


    #controlled Component
    ======================

        Form has the default HTML form behavior of browsering to a new page when the user submits the form. if you want this behaviour in react, it just works. but in the most cases, it's conveninet to have jsavscript function that handles the submission fo the form and he access to the data that the user entered into the form. The standard way to achieve this is with a technique called "Controlled component"

        In a controlled component, from data is handled by a react Component

    #when use controlled component

        You need to write an event handler for every way your data can change and pipe all of the input state through a react component



    #Uncontrolled Component
    =======================

        In a controlled component, form data is handle by a react component. The alternative is Uncontrolled components, where form data is handled by the DOM itself.

        To write an Uncontrolled component, Instead of writing an event handler for every state update, you can use a 'ref' to get form the DOM.

    #when use Uncontrolled component

        you do not need to write an event handler for every way your data can change and pipe all of the input state through a React Component.

        Converting a prexisting codebase to react, or integrating a React application with a non-React library 

        Managing focus, text selection or media playback 
        Triggering imperative animations
        integrating with third-party DOM  

=================================================================================================================================
#Higher Order Component

    A Higher-Order Component (HOC) is an advanced technique in react for resuing component logic.
    HOCs are common in third-party React libraries 
    A HOC is a function that takes a component and returns a new component 

    Syntax : - 
        const EnhancedComponent = HigherOrderCompeonent(WrappedComponent)

    Ex : 
        const FacebookJob = withLanguage(ReactJS)
        const Army = withArm(Men)

    #when we use 
    ============
        When we implementing same logic in different-different Component (to remove retendency)        

=================================================================================================================================
#Error Boundries 

    Error Boundries are React Component that catch javascript errors anywhere in their child component tree, log those errors, and display a fallback UI Instead of the Component tree that crashed. Error Boundries catch errors during rendering, in lifecycle methods and in constructors of the whole tree below them.

    A class component becomes an error boundry if it defines either (or both) of the lifecycle method staticgetDrivedStateFormError() or ComponentDidCatch().


    Error boundries do not catch errors for :

        1. Event handlers 
        2. Asynchronous code (e.g setTimeout or RequestAnimationFrame Callbacks)
        3. Server side Rendering 
        4. Errors throw in the error boundry itself(rather than its children) 



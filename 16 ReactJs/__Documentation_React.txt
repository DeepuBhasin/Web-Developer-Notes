What is React ?
- Javascript library used to create websites 
- Allows to easily create Single Page Apps - SPA's for short
- in intial request server send only index.html file and the react perform whole functionality like user interctivity, 
fetching data, routing, click events etc
- with the help of routing react inject that code which belongs to that route

=========================================================================================================================
@Installation

- npx create-react-app folder-name
- cd folder-name
- npm run start

- default server Address : http://localhost:3000/

=========================================================================================================================
@Components

- Components let you split the UI into independent, reusable pieces, and think about each piece in isolation. This page 
provides an introduction to the idea of components.
- React is Component based architecture
- Component means perform single task

=========================================================================================================================
@JSX

- JSX stands for JavaScript XML. JSX allows us to write HTML in React. JSX makes it easier to write and add HTML in React.
- Write XML-Like code for elements and components.
- JSX tags have a tag name, attributes and children.
- JSX is not a necessity to write React applications.
- JSX makes your code simpler and elegant.
- bable will convert this jsx file into plan javascript code
- Reserve key words
	className	: class 
	forHtml		: for

React V17 > no need to import 'react'

=========================================================================================================================
@Variables and Interpolation

- you can write any javascript code with in the functional component 
- you can write javascript code in the curly brackets 
	
	{(function () { alert('Hello') })()}					// writing IIFE code directly in Interpolation 

- '{}' curly brackets are use to print any variable in JSX
		
	function App() {
		const name = "Deepinder Singh";						// writing javascript code here
		const count = 50
		return (
			<h1>{name} {50}</h1>
		)
	}

	export deafult App

- JSX convert output into string
- cannot print objects and booleans value
- print expresion, numbers directly, array directly
	
		{10 + 10 }				// 20			: write numbers 
		{'hello'}   			//	hello 		: write string
		{[1, 2, 3, 4, 5, 6]}	// 123456		: write array
		{'hello'.toUpperCase()}	// HELLO 		: write functions

- dynamic data
	
	const link = 'https://www.google.com';
	<a href={link}>Google</a>		

=========================================================================================================================
@State

- State is used to store property values that belongs to the component, that have to be rendered to the view
- State holds the data and can change over time
- State can only be used with in components
- Event handlers generally update state
	
	Functional component : 
	----------------------	
		
		const [name,setName] = useState('Deepu');		// declaring 
		
		{name}											// printing value

		setName('Deepinder')							// mutating state

	class component : 
	---------------

		this.state = {									// declaring state 
			name : 'Deepu'
		}

		{this.name}										// print value

		this.setState({name : 'Deepinder'})				// mutating state


#useState() : Hook

- The React useState Hook allows us to track state in a function component.
	State generally refers to data or properties that need to be tracking in an application.

- useState is a React Hook that lets you add a state variable to your component.

- useState returns an array with exactly two values:
	The current state. During the first render, it will match the initialState you have passed.
	The set function that lets you update the state to a different value and trigger a re-render.


	Problem 
	-------

	function Home = () => {
		let name = 'mario'; 			// this variable is not reactive means react does not watching if it changes

		const handleClick = () => {
			name = 'Deepu';				// and even if it change values it will not re-render the DOM with new value
			console.log(name);
		}

		return (
			<div>
				{name}
				<button onClick={handleClick}> Change Name </button>
			</div>
		)
	}


	Solution 
	--------

	import {useState} from 'react';

	function Home = () => {
		let [name, setName] = useState(''); 		// now our variable become reactive and react will watch this variable all the time	

		const handleClick = () => {
			setName('Deepu');			// and here if it change get value then react will automatically update state and re-render component 
		}

		return (
			<div>
				{name}
				<button onClick={handleClick}> Change Name </button>
			</div>
		)
	}

#Class Component
----------------
	
	State Updates May Be Asynchronous : React may batch multiple setState() calls into a single update for performance.	

	#With Simple Count
	------------------
	
		import React from 'react';
		import './App.css'
		class App extends React.Component {
		  constructor() {
		    super();
		    this.state = {
		      count: 1
		    }
		  }

		  incrementHandler = () => {
		    this.setState({													// work asynchronously, update in DOM later
		      count: this.state.count + 1
		    },
		      () => {
		        console.log('callback function', this.state.count);			// callback function for after asynchronous 
		      }
		    )

		    console.log('sychronous', this.state.count);					// sychronous task
		  }

		  render() {
		    return (
		      <div className='App'>
		        <div>Count : {this.state.count}</div>
		        <div><button onClick={this.incrementHandler}>Update</button></div>
		      </div>

		    )
		  }

		}
		export default App;

	#With previous Count
	--------------------
		React may batch multiple setState() calls into a single update for performance.	

	#problem -> 
	-----------
		
		import React from 'react';
		import './App.css'
		class App extends React.Component {
		  constructor() {
		    super();
		    this.state = {
		      count: 0
		    }
		  }
		  incrementHandler = () => {
		    this.setState({
		      count: this.state.count + 1
		    },
		      () => {
		        console.log('callback function', this.state.count);
		      }
		    )

		    console.log('sychronous', this.state.count);
		  }

		  incrementHandlerFive = () => {
		    this.incrementHandler();
		    this.incrementHandler();
		    this.incrementHandler();
		    this.incrementHandler();
		    this.incrementHandler();

		  }

		  render() {
		    return (
		      <div className='App'>
		        <div>Count : {this.state.count}</div>
		        <div><button onClick={this.incrementHandlerFive}>Update</button></div>
		      </div>

		    )
		  }

		}
		export default App;

	#solution
	---------
		
		import React from 'react';
		import './App.css'
		class App extends React.Component {
		  constructor() {
		    super();
		    this.state = {
		      count: 0
		    }
		  }
		  incrementHandler = () => {
		    this.setState((state, props) => ({
		      count: state.count + 1
		    }),
		      () => {
		        console.log('callback function', this.state.count);
		      }
		    )

		    console.log('sychronous', this.state.count);
		  }

		  incrementHandlerFive = () => {
		    this.incrementHandler();
		    this.incrementHandler();
		    this.incrementHandler();
		    this.incrementHandler();
		    this.incrementHandler();

		  }

		  render() {
		    return (
		      <div className='App'>
		        <div>Count : {this.state.count}</div>
		        <div><button onClick={this.incrementHandlerFive}>Update</button></div>
		      </div>

		    )
		  }

		}
		export default App;

#Note : for setState
	
	1. Always make use of setState and never modify the state directly.
	2. Code has to be executed after the state has been updated ? Place that code in the callback function which is the 
	second argument to the setState method
	3. When you have to update state based on the previous state value, pass in a function as an argument instead of the
	regular object
	


=========================================================================================================================
@React Developer Tools -extention

	-component : will tell each and every component
	
=========================================================================================================================
@Props

- React Props are like function arguments in JavaScript and attributes in HTML.
- To send props into a component, use the same syntax as HTML attributes:
	
	<Car brand="Ford" />
- Props is Object type
- destructring is one the best way to use props
- when ever you change props component get re-render
	
	Functional component : {props.name}

	class component 	 : {this.props.name}

- props are immutable example (read only property)
	
	this.props.name = name 			// will cause error because these are immutable

	{this.props.name}

=========================================================================================================================
@Props.children
	
	is use to send content from parent to child component

#App.js
-------
		const App = () => {
			return (
				<Child>Hello World </Child>
			)
		}
		
		export default App;

#Child.js
---------
	
	const Child = (props) => {
		return (
			<div><h1>{props.children}</h1></div>
		)
	}

	export default Child;	


=========================================================================================================================
@Multiple Component
	
	App.js 						 				// Root component
	 |
	 |------- Navbar.js     					// Sub Component of root component
	 |------- BlogDetails.js 					// Sub component of root component
	 |------- SideBar.js 						// Sub component of root component
	 			|
	 			|-------- Categories.js 		// Sub component of SideBar component
	 			|-------- Tags.js 				// Sub component of SideBar component

- while importing component don't need to write .js/.jsx at the end, react managing by its own.
	
	import Navbar from './component/nav-bar/nav-bar.component'

	<Navbar />	 			

=========================================================================================================================
@Style in JSX 
	
- object are use create properties and values
- camelCasing is use instead of kabba-case 
	
	style={{									// creating object
        color: 'white',
        backgroundColor: '#1356d'				// camalCasing for background-color
    }}

=========================================================================================================================
@Classes in JSX

- create class and import that file name
	
	index.css 									// creating file
		.navbar {
		    padding: 20px;
		    display: flex;
		    align-items: center;
		    max-width: 600px;
		    margin: 0 auto;
		    border-bottom: 1px solid #f2f2f2;
		}
 
 	import './App.css';							// importing file into component

- always try to place file in same folder of particular component

=========================================================================================================================
@Events

- always pass function object (best approch)
	
	Example
	-------
		<button onClick={handleClick}> Click Me </button>

- calling function nested function
	
	Example
	--------
		<button onClick={() => handleClick()}> Click Me </button>	

- Never call function directly in events
	
	Example
	--------
		<button onClick={handleClick()}> Click Me </button>				// it excecute in the beigning

- always create different fuction instead writing directly
	
	function App() {
		function handleClick() {
			alert('Hello world');
		}
		
		return(
				<button onClick={handleClick}> Click Me </button>		// passing function object reference
		)
	}

- passing argumenats : wrap that function using arrow function
	
	function App() {
		function handleClick(name) {
			alert(name);
		}
		
		return(
				<button onClick={()=> handleClick('Deepinder Singh')}> Click Me </button>	// passing function object reference
		)
	}

- Event object : you will get always event object when ever you call any function


#Function component	
	
	a. in Regular functions

		function App() {
			function handleClick(e) {
				console.log(e)											// getting event object
			}
			
			return(
					<button onClick={handleClick}> Click Me </button>				
			)
		}

	b. in Arrow functions

		function App(e) {
			function handleClick(eventObject, name) {
				console.log('Object', e);								// getting event object
				console.log('name', name);								// getting name parameter
			}
			
			return(
					<button onClick={(e)=> handleClick(e,'Deepinder Singh')}> Click Me </button>	
			)
		}

#Class Component
----------------
	
	#problem
	--------

		import React from 'react';
		import './App.css'
		class App extends React.Component {
		 	incrementHandler() {
		    console.log(this);				// undefined beacuse it not bind to react app			
		  }
		  render() {
		    return (
		      <div className='App' >
		        <div><button onClick={this.incrementHandler}>Update</button></div>
		      </div>
			)
		  }
		}
		export default App;

	#solution
	---------

		1. bind method in render
		------------------------

			import React from 'react';
			import './App.css'
			class App extends React.Component {
			  constructor() {
			    super();
			    this.state = {
			      count: 0
			    }
			  }
			  incrementHandler() {
			    this.setState(state => ({
			      count: state.count + 1
			    }))
			  }
			  render() {
			    return (
			      <div className='App' >
			        <div>Count : {this.state.count}</div>
			        <div><button onClick={this.incrementHandler.bind(this)}>Update</button></div>		// binding event
			      </div>

			    )
			  }

			}
			export default App;

		2. bind in constructor (best option right now)
		----------------------------------------------

			import React from 'react';
			import './App.css'
			class App extends React.Component {
			  constructor() {
			    super();
			    this.state = {
			      count: 0
			    }
			    this.incrementHandler = this.incrementHandler.bind(this)				// binding evevnt
			  }
			  incrementHandler() {
			    this.setState(state => ({
			      count: state.count + 1
			    }))
			  }
			  render() {
			    return (
			      <div className='App' >
			        <div>Count : {this.state.count}</div>
			        <div><button onClick={this.incrementHandler}>Update</button></div>
			      </div>

			    )
			  }

			}
			export default App;

		3. With arrow function 
		----------------------	

			import React from 'react';
			import './App.css'
			class App extends React.Component {
			  constructor() {
			    super();
			    this.state = {
			      count: 0
			    }

			  }
			  incrementHandler = () => {						// binding with arrow function
			    this.setState(state => ({
			      count: state.count + 1
			    }))
			  }
			  render() {
			    return (
			      <div className='App' >
			        <div>Count : {this.state.count}</div>
			        <div><button onClick={this.incrementHandler}>Update</button></div>
			      </div>

			    )
			  }

			}
			export default App;

=========================================================================================================================
@Lifting UpState

- Passing callback function from parent to child and calling that function from child : it help to send data from child 
to parent

	function App() {
		const handleAlertEvent = (name) => {						// creating function 
			alert(name);
		}

		return (
			<Child handleEvent={handleAlertEvent}/>					// passing that function Object to child
		)
	}


	function Child(props) {
		const handleEvent = props.handleEvent;						// getting that function in props and passing into variable

		return (
			<div>
				<button onClick={()=> handleEvent('Deepu')}>Alert Message </button>		// calling parent function 
			</div>
		)
	}

=========================================================================================================================
@Hooks

- special functions
- Allow us to do additional things inside functional components eg 
	1. useState 	: use state within a functional component
	2. useEffect 	: run code when a component renders (or re-renders)
	3. useContext	: consume context in a functional component
	4. useSelector	: get the values from the store
	5. useDispatch	: dispatch the action from component to store
	6. useMemo		: useMemo returns a memoized value 
	7. useCallback	: useCallback returns a memoized function.
	8. useRef		: 


=========================================================================================================================
@useEffect Hook

- The useEffect Hook allows you to perform side effects in your components.
- this hook run during initilization of component / means rendering initill
- this hook run also when ever state get changes
- useEffect accepts two arguments. The second argument is optional.
	useEffect(<function>, <dependency>)


	function Timer() {
	  const [count, setCount] = useState(0);

	  useEffect(() => {
	    setTimeout(() => {
	      setCount((count) => count + 1);
	    }, 1000);
	  });

	  return <h1>I've rendered {count} times!</h1>;
	}

	Note : But wait!! It keeps counting even though it should only count once!. useEffect runs on every render. That means that 
	when the count changes, a render happens, which then triggers another effect.

#No dependency passed:
----------------------

	useEffect(() => {
	  //Runs on every render
	});	

#An empty array:
----------------

	useEffect(() => {
	  //Runs only on the first render
	}, []);

#Props or state values:
-----------------------

	useEffect(() => {
	  //Runs on the first render
	  //And any time any dependency value changes
	}, [prop, state]);


	example 

	const [name,setName] = useState('dp')
	const [age,setAge] = useState(10)

	useEffect(() => {
	  //Runs on the first render
	  //And any time any dependency value changes
	}, [age]);											// it means useEffect will run on age state get change not for the name state

	

#Effect Cleanup
---------------

- Some effects require cleanup to reduce memory leaks.
- Timeouts, subscriptions, event listeners, and other effects that are no longer needed should be disposed.
- We do this by including a return function at the end of the useEffect Hook.
		
		function Timer() {
		  const [count, setCount] = useState(0);

		  useEffect(() => {
		    let timer = setTimeout(() => {
		    setCount((count) => count + 1);
		  }, 1000);

		  return () => clearTimeout(timer)
		  }, []);

		  return <h1>I've rendered {count} times!</h1>;
		}

#Fetch method in UseEffect
--------------------------
	
- fetch must use with then methods
- async-await method can be use but outside the useEffect function by creating async-await function	
- useEffect is synchronouse function, so it will not allowed to use async-await there

#async-await in useEffect
-------------------------
		useEffect(() => {
			const getUserData = async() => {
				let userData = await fetch('any_url');
				let userData = await userData.json();
				cosnole.log(userData);
			}	

			getUserData();
		})


=========================================================================================================================
@Json PlaceHolder

1. npm install -g json-server
2. create file : data (folder)/db.json (file)
3. Add Data 
	
	{
	    "posts": [
	        {
	            "userId": 1,
	            "id": 1,
	            "title": "sunt aut facere repellat provident occaecati excepturi optio reprehenderit",
	            "body": "quia et suscipit\nsuscipit recusandae consequuntur expedita et cum\nreprehenderit molestiae ut ut quas totam\nnostrum rerum est autem sunt rem eveniet architecto"
	        },
	        {
	            "userId": 1,
	            "id": 2,
	            "title": "qui est esse",
	            "body": "est rerum tempore vitae\nsequi sint nihil reprehenderit dolor beatae ea dolores neque\nfugiat blanditiis voluptate porro vel nihil molestiae ut reiciendis\nqui aperiam non debitis possimus qui neque nisi nulla"
	        },
	    ]
    }

4. npx json-server --watch data/db.json --port 8000
5. http://localhost:8000/blogs 

- when ever you insert data we should not send id, json server create automatically for us 


=========================================================================================================================
@Custom Hook

- Hooks are reusable functions
- When you have component logic that needs to be used by multiple components, we can extract that logic to a custom Hook.
- Custom Hooks start with "use". Example: useFetch.
- destructuring 
	- with array 	: order Matters
	- with object 	: order does not matter

#Example of Custom Hook
-----------------------
	
	import { useState, useEffect } from 'react';
	const useFetch = (url) => {
	    const [data, setData] = useState(null);
	    const [isPending, setIsPending] = useState(true);
	    const [error, setError] = useState(null);

	    useEffect(() => {												// creating useEffect Method
		    let counter = setTimeout(() => {
		        fetch(url)
		            .then(result => {
		                if (!result.ok) {
		                    throw new Error('could not fetch the data for that resource');
		                }
		                return result.json();
		            })
		            .then(result => {
		                setData(result);
		                setIsPending(false);
		                setError(null);
		            })
		            .catch(err => {
		                setIsPending(false)
		                setError(err.message);

		            });	
		        }, 1000);
			return () => { clearTimeout(counter); }    					// cleaning up useEffect (componentWillUnmount)
	    }, [url]);														// passing dependency values to the useEffect

	    return { data, isPending, error };								// exporting the values in objects
	}

	export default useFetch;


	using Custom Hook
	-----------------

	function Home() {
	    const { data, isPending, error } = useFetch('http://localhost:8000/blogs')		// passing the address to that custom hook
	    return (
	        <div className='home'>
	            {error}
	            {isPending}
	            {data}
	        </div>
	    )
	}
	
=========================================================================================================================
@React-Router

- npm install react-router-dom
- Example
	
	import { BrowserRouter, Route, Routes } from 'react-router-dom';

	function App() {
	  return (
	    <BrowserRouter>													// in this component your all routes will handle
	      <div className="App">
	        <Navbar />											
	        <div className='content'>
	          <Routes>													// this component will help to print route	
	            <Route path='/' element={<Home />}></Route>				// this will help to print particuler component according to path
	          	<Route path='/create' element={<Create />}></Route>
            	<Route path='/blog/:id' element={<BlogDetails />}></Route>
            	<Route path='*' element={<NotFound />}></Route>			// use astrick to if data not route not found	
	          </Routes>
	        </div>
	      </div>
	    </BrowserRouter>
	  );
	}

	export default App;	

- react match routes from top to bottom in routes component and it will search particular path untill it get match 	


#link
-----

	import { Link } from "react-router-dom";					// importing link module
	const Navbar = () => {
	    return (
	        <nav className="navbar">
	            <h1>The Dojo Blog</h1>
	            <div className="links">
	                <Link to="/"> Home</Link>					// creating root "/" link
	                <Link to="/create" style={{					// creating create "/create" link
	                    color: 'white',
	                    backgroundColor: '#f1356d'
	                }}>New Blog</Link>
	            </div>
	        </nav>
	    )
	}

	export default Navbar;

#params
-------

	import { useParams } from "react-router-dom";
	const BlogDetails = () => {
	    const { id } = useParams();						// using parameter hook
	    return (
	        <div className="blog-details">
	            <h2>Blog Details : {id}</h2>			// printing value to id
	        </div>
	    )
	}

	export default BlogDetails;

#Programmatically-Navigation
----------------------------
	
	import { useNavigate } from 'react-router-dom' 		

	let navigation = useNavigate();						// getting function Object using useNavigation hook

	navigation('/create');								// pushing to route

=========================================================================================================================
@Reuse of useEffect
	
	const BlogDetails = () => {
    const { id } = useParams();																	// getting the values from Param
    const { data, error, isPending } = useFetch(`http://localhost:8000/blogs/${id}`);			// getting the values using ID

    return (
	        <div className="blog-details">
	            {isPending&& <div>Loading....</div>}
	            {error && <div>{error}</div>}
	            {data && (
	                <article>
	                    <h2>{data.title}</h2>
	                    <p>Written By {data.author}</p>
	                    <div>{data.body}</div>
	                </article>
	            )}
	        </div>
	    )
	}	

=========================================================================================================================
@Controlled Inputs

- input field get sync with state
- input value should be onChange with using key:pair value
- submit the data using onsSubmit data

#best Example
	
	import { useState } from 'react';
const Create = () => {

    const formDefaultValues = {
        title: '',
        body: '',
        author: ''
    };

    const [userData, setUserData] = useState(formDefaultValues);
    const { title, body, author } = userData;
    const handleEvent = (e) => {
        const { name, value } = e.target;
        setUserData({ ...userData, [name]: value });
        console.log(userData);
    }

    const onSubmitEvent = (e) => {
        e.preventDefault();
		console.log(userData);
    }

    return (
        <div className="create">
            <h2>Add New Blog</h2>
            <form onSubmit={onSubmitEvent} method="POST">
                <label>Blog Title</label>
                <input
                    name='title'
                    type="text"
                    required
                    placeholder="Enter Title"
                    value={title}
                    onChange={handleEvent}
                />

                <label>Blog Body</label>
                <textarea
                    name='body'
                    required
                    placeholder="Enter Blog Body"
                    value={body}
                    onChange={handleEvent}
                >
                </textarea>

                <label>Blog Author</label>
                <select
                    name='author'
                    required
                    value={author}
                    onChange={handleEvent}
                >
                    <option value="">Select Author</option>
                    <option value="Dp">Dp</option>
                    <option value="Deepu">Deepu</option>
                    <option value="Deepinder">Deepinder</option>
                </select>

                <button type="submit">Add Blog</button>

            </form>
        </div>
    )
}
export default Create;
	

=========================================================================================================================
@React Context-Api
	
	Context-Api :  
		- Context provides a way to pass data through the component tree without having to pass props down manually at every level.
		- practical application use is configuration of theme
		- Clear & easy way to share state within a components tree, it same like Redux but it is easy then redux and light weight
		- hooks with functional components are easy as compair to with class context
	
	Hooks : Tap into the inner working of react in functional components

	Redux : contextApi + useReducer() hook  


- class based context api
- functional based context api


#Example
--------
	
	#creating context 
	-----------------

	import { createContext, useState } from 'react';
	
	let stateDefaultValue = {									// creating default values
	    isLightTheme: false,
	    light: { syntax: '#555', ui: '#ddd', bg: '#eee' },
	    dark: { syntax: '#ddd', ui: '#333', bg: '#555' },
	}

	export const ThemeContext = createContext({					// creating default values for the context
	    color: stateDefaultValue,
	    setColor: () => null
	});


	const ThemeContextProvider = (props) => {					// creating Provider  for varous components
	    const [color, setColor] = useState(stateDefaultValue);	
	    const value = { color, setColor };						// creating prop value to use in sub-component	
	    return (
	        <ThemeContext.Provider value={value}>				// creating wrapper for child components
	            {props.children}								// printing components what ever we are passing 
	        </ThemeContext.Provider>							
	    )
	}

	export default ThemeContextProvider;


	#Wrapping components
	--------------------

	import Navbar from './component/navbar.component';
	import BookList from './component/booklist.component';
	import ThemeContextProvider from './context/theme.context';
	import ThemeToggleButtom from './component/theme-toggle-button.component'

	function App() {
	  return (
	    <div className="App">
	      <ThemeContextProvider>					// wrapping components
	        <Navbar />								// child component where you want to pass props values
	        <BookList />							// child component where you want to pass props values	
	        <ThemeToggleButtom />
	      </ThemeContextProvider>
	    </div>
	  );
	}

	export default App;


	#calling function 
	-----------------

	import { useContext } from "react"
	import { ThemeContext } from "../context/theme.context"
	const ThemeToggleButtom = () => {
	    const { color, setColor } = useContext(ThemeContext);				// getting the value and function from context using hook
	    const { isLightTheme } = color;										

	    const handleEvent = () => {
	        setColor({ ...color, isLightTheme: !isLightTheme });			// here we are creating new object and Changing pervious values
	    }

	    return (
	        <>
	            <button onClick={handleEvent}>Change Color</button>			// calling that event to change values of context
	        </>
	    )
	}

	export default ThemeToggleButtom;

	#using Context Values
	---------------------

	import { ThemeContext } from './../context/theme.context'
	import { useContext } from 'react'
	const BookList = () => {
	const { color } = useContext(ThemeContext);										// getting value from the context api 
	console.log('yes', color);
	const { isLightTheme, light, dark } = color;									// destructuring context api values
	const theme = isLightTheme ? light : dark;
	console.log('theme', color);
	return (
	    <div className="book-list" style={{ backgroundColor: theme.ui, color: theme.syntax, }} >
	        <ul>
	            <li style={{ backgroundColor: theme.ui }}>the way of kings</li>
	            <li style={{ backgroundColor: theme.ui }}>the name of the wind</li>
	            <li style={{ backgroundColor: theme.ui }}>the final empire</li>
	        </ul>
	    </div>
	);
	}

	export default BookList;

=========================================================================================================================
@Multiple-context-api
	
	const { color1 } = useContext(ThemeContext1);	
	const { color2 } = useContext(ThemeContext2);	
	const { color3 } = useContext(ThemeContext3);	

=========================================================================================================================
@uuid-package
	
- npm i react-uuid
- import uuid from 'react-uuid';
- console.log(uuid());	//			47b928d8-8b13-8944-8326-f923ae113c98

=========================================================================================================================
@Reducers
	
		
				Action 															  Reducer Function

	dispatch({type : 'LIGHT_COLOR', payload})------------------------>			reducer(action, state)
																       		interacts with the state/data	
																       					 |
																       					 |
																       					 |

																       			- check the action.type
																       			- update the state object
																       			- return the state	
																       					 |
																       					 |
																       					 -> Provider value			


#useReducer()

- The useReducer Hook is similar to the useState Hook.
- It allows for custom state logic.
- If you find yourself keeping track of multiple pieces of state that rely on complex logic, useReducer may be useful.

useReducer(<reducer>, <initialState>);



The reducer function contains your custom state logic and the initialStatecan be a simple value but generally will contain an object.

The useReducer Hook returns the current stateand a dispatchmethod.



#complete Example (Constants + Reduce + ContextApi + Reducer)
-------------------------------------------------------------

#constants.js 
-------------
	
	export const INECRMENT_ACTION = 'INECRMENT_ACTION';
	export const DECREMENT_ACTION = 'DECREMENT_ACTION';
	export const INECRMENT_BY_VALUE_ACTION = 'INECRMENT_BY_VALUE_ACTION';
	export const DECREMENT_BY_VALUE_ACTION = 'DECREMENT_BY_VALUE_ACTION'; 

#reducer.js
-----------
	
	import {
	    INECRMENT_ACTION,
	    DECREMENT_ACTION,
	    INECRMENT_BY_VALUE_ACTION,
	    DECREMENT_BY_VALUE_ACTION
	} from './../constants/index'

	export const initialValue = 0;

	export const reducer = (state, action) => {
	    switch (action.type) {
	        case INECRMENT_ACTION:
	            return state = state + 1;
	        case DECREMENT_ACTION:
	            return state = state - 1;
	        case INECRMENT_BY_VALUE_ACTION:
	            return state = state + action.num;
	        case DECREMENT_BY_VALUE_ACTION:
	            return state = state - action.num;
	        default:
	            return state;
	    }
	}

#context.js
-----------
	
	import { createContext, useReducer } from "react";
	import { initialValue, reducer } from './../reducer/reducer'

	export const CountContext = createContext();

	const Count = (props) => {
	    const [count, dispatch] = useReducer(reducer, initialValue)
	    return (
	        <CountContext.Provider value={{ count, dispatch }}>
	            {props.children}
	        </CountContext.Provider >
	    )
	}

	export default Count;

#show-count.component.js
------------------------
	
	import { useContext } from 'react'
	import { CountContext } from './../context/index'
	const ShowCount = () => {
	    const { count } = useContext(CountContext)
	    return (
	        <h1>Count Value : {count}</h1>
	    )
	}

	export default ShowCount;	

#buttons.component.js
---------------------
	
	import { useContext } from 'react'
	import { CountContext } from './../context/index'
	import {
	    INECRMENT_ACTION,
	    DECREMENT_ACTION,
	    INECRMENT_BY_VALUE_ACTION,
	    DECREMENT_BY_VALUE_ACTION
	} from './../constants/index'
	const Button = () => {
	    const { dispatch } = useContext(CountContext);
	    return (
	        <>
	            <h3>Increment Values</h3>
	            <div>
	                <button onClick={() => dispatch({ type: INECRMENT_ACTION })} >Incerment</button>
	            </div>
	            <div>
	                <button onClick={() => dispatch({ type: DECREMENT_ACTION })} >Decerment</button>
	            </div>
	            <div>
	                <button onClick={() => dispatch({ type: INECRMENT_BY_VALUE_ACTION, num: 5 })} >Incerment By 5</button>
	            </div>
	            <div>
	                <button onClick={() => dispatch({ type: DECREMENT_BY_VALUE_ACTION, num: 5 })} >Decerment By 5</button>
	            </div>

	        </>
	    )
	}

	export default Button;

#App.js
-------
	
	import ShowCount from './component/show-count.component';
	import Button from './component/buttons.component'
	import Count from './context/index'
	function App() {
	  return (
	    <div className="App">
	      <Count>
	        <ShowCount />
	        <Button />
	      </Count>
	    </div>
	  );
	}

	export default App;
	
=========================================================================================================================
@Redux
	
- a layer on-top of react 
- Helps with state management of our app 
	- data in the app 
	- UI state of the app 

	Redux - stores, actions & reducers


#command
--------
	npm install redux react-redux

	redux 		: its a library for creating store
	react-redux : its create a bridge which allow you to connect redux with react 

#structures
-----------
	
	1. store
	2. constants
	3. actions
	4. reducers
	5. index.js 		// wrap up store


- Example of redux synchrounous
  -----------------------------		

#store.js 
---------
	
	import { createStore } from "redux";
	import { Provider } from "react-redux";
	import rootReducer from "../reducers/index";

	export const store = createStore(rootReducer);
	export default Provider;

#index.js
---------
	
	import Provider, { store } from './redux/store/index'

	const root = ReactDOM.createRoot(document.getElementById('root'));
	root.render(
	  <Provider store={store}>
	    <App />
	  </Provider>
	);
	reportWebVitals();

#constnats.js
-------------

	export const DELETE_POST = 'DELETE_POST';

#action.js
----------	
	
	import { DELETE_POST } from "../constants"

	export const deletePost = (id) => {
	    return {
	        type: DELETE_POST,
	        id: id
	    }
	}


#reducers.js
------------
	
	import { DELETE_POST } from "../constants/index";

	const initialState = {
	    posts: [
	        {
	            "userId": 1,
	            "id": 1,
	            "title": "sunt aut facere repellat provident occaecati excepturi optio reprehenderit",
	            "body": "quia et suscipit\nsuscipit recusandae consequuntur expedita et cum\nreprehenderit molestiae ut ut quas totam\nnostrum rerum est autem sunt rem eveniet architecto"
	        },
	        {
	            "userId": 1,
	            "id": 2,
	            "title": "qui est esse",
	            "body": "est rerum tempore vitae\nsequi sint nihil reprehenderit dolor beatae ea dolores neque\nfugiat blanditiis voluptate porro vel nihil molestiae ut reiciendis\nqui aperiam non debitis possimus qui neque nisi nulla"
	        },
	        {
	            "userId": 1,
	            "id": 3,
	            "title": "ea molestias quasi exercitationem repellat qui ipsa sit aut",
	            "body": "et iusto sed quo iure\nvoluptatem occaecati omnis eligendi aut ad\nvoluptatem doloribus vel accusantium quis pariatur\nmolestiae porro eius odio et labore et velit aut"
	        }
	    ]
	}
	const rootReducer = (state = initialState, action) => {
	    switch (action.type) {
	        case DELETE_POST:
	            {
	                let newPost = state.posts.filter(item => item.id !== action.id);
	                return {
	                    ...state,               // if we add new states in future
	                    posts: newPost
	                }
	            }
	        default:
	            return state;
	    }
	}

	export default rootReducer;

	#Note : actully we did not modify the original state,  instead we just create new object/array then insert new values in that object	

#App.js
-------
	
	import './App.css';
	import { connect } from 'react-redux'
	import { deletePost } from './redux/actions/actions';


	function App(props) {
	  const { posts, deletePost } = props;
	  return (
	    <div className="App">
	      {posts.map(item => {
	        return (
	          <div key={item.id}>
	            <h1 >{item.title}</h1>
	            < p ><button onClick={() => { deletePost(item.id) }}>Delete</button></p>
	          </div>
	        )
	      })
	      }
	    </div>
	  )
	}

	const mapStateToProps = (state, componentProps) => {					// connecting state to current component props
	  return {
	    posts: state.posts
	  }
	}

	const mapDispatchToProps = (dispatch) => {								// connecting state to current methods to props
	  return {
	    deletePost: (id) => dispatch(deletePost(id))
	  }
	}

	export default connect(mapStateToProps, mapDispatchToProps)(App);		// connecting current component with redux using connect method

=========================================================================================================================
@Redux + middleware(thunk) + devtools

#Three principle of Redux 
-------------------------
	
	First Principle : 
	-----------------
		"The state of your whole application is stored in an object tree within a single store" means maintain our application state in a single object which would be managed by the redux store

		example: 	
			{
				post: [],
				loading : true, 
				error  : null
			}

	Second principle : 
	------------------

		"The only way to change the state is to emit an action, an object describing what happened" means to update the state of your app, you need to let redux know about that with an action. 

		example : 
			const fetch_data = () => {
				return { 
					type : 'FETCH_DATA',
					payload : [1,2,3]
				} 
			} 

	Third Principle :
	-----------------
		"To specify how the state tree is transformed by actions, you write pure reducers" means 

		example : 

			let initialValue = {
				post : []
			};

			const reducer = (state = initialValue, action) => {
				switch(action.type) {
					case 'FETCH_DATA' : {
						return 	 {
							...state,
							post : action.payload 
						}
					}
				}
			}

	#Redux Store
	------------

		1. Holds application state				
		2. Allows access to state via getState();
		3. Allows state to updated via dispatch(action)


#Three principle Overview


		dispatch 															new State
	UI ----------> Action Object --------> Middleware ---------> Reducer --------------> Store-----------
	^																^									|
	|	current state 												|		current State				|
	-----------------------------------------------------------------------------------------------------		


	Middleware : its just a function which returns a function	

		const myLogger1 = (store) => {
		    return next => {
		        return (action) => {
		            console.log('second middle');
		            return next(action);
		        }
		    }
		}	

	Why is fetchposts not working 
	1. Action creators can only return plain javascript objects with a type property
	2. The action will get sent to the reducer before the data is fetched from the Api		

	solution : thunk 

	#command 
		npm install redux react-redux
		npm install redux-thunk	 
		npm install axios
		npm install redux-devtools-extension
		npm i --save redux-logger

	#Loading & Error Handling
		1. Make use of the Request/success/failure pattern to handle loading and error state
		2. Separate action for Request, Success and Failure	


#Example
	
#constants.js 
-------------
	
	export const FETCH_DATA = 'FETCH_DATA';
	export const DELETE_DATA = 'DELETE_DATA';

	export const FETCH_POSTS_REQUEST = 'FETCH_POSTS_REQUEST';
	export const FETCH_POSTS_SUCCESS = 'FETCH_POSTS_SUCCESS';
	export const FETCH_POSTS_FAILUER = 'FETCH_POSTS_FAILUER';

#actions.js 
-----------
	
	import axios from "axios"
	import { DELETE_DATA, FETCH_POSTS_FAILUER, FETCH_POSTS_REQUEST, FETCH_POSTS_SUCCESS, } from './contanst.js'

	export const FETCH_DATA_ACTION = () => {
	    return async (dispatch, getState) => {
	        dispatch({ type: FETCH_POSTS_REQUEST, payload: [] })

	        try {
	            const responseData = await axios.get('https://jsonplaceholder.typicode.com/posts');
	            dispatch({ type: FETCH_POSTS_SUCCESS, payload: responseData.data });
	        }
	        catch (error) {
	            dispatch({ type: FETCH_POSTS_FAILUER, error: error });
	        }

	    }
	}

	export const DELETE_DATA_ACTION = () => {
	    return {
	        type: DELETE_DATA,
	        payload: []
	    }
	}	

#reducers.js 
------------
	
	import { DELETE_DATA, FETCH_DATA, FETCH_POSTS_REQUEST, FETCH_POSTS_SUCCESS, FETCH_POSTS_FAILUER } from "./contanst"

	const initialState = {
	    post: [],
	    loading: false,
	    error: null
	}

	const reducer = (state = initialState, action) => {
	    switch (action.type) {
	        case FETCH_POSTS_REQUEST: {
	            return { ...state, loading: true, error: null }
	        }
	        case FETCH_POSTS_SUCCESS: {
	            return { ...state, loading: false, post: action.payload, error: null }
	        }
	        case FETCH_POSTS_FAILUER: {
	            return { ...state, loading: false, error: action.error }
	        }
	        case FETCH_DATA: {
	            return { ...state, loading: false, post: action.payload, error: null }
	        }
	        case DELETE_DATA: {
	            return { ...state, loading: false, post: action.payload, error: null }
	        }
	        default: {
	            return state;
	        }
	    }
	}

	export default reducer;

#store.js
---------
	
	import { applyMiddleware, createStore } from "redux";
	import { composeWithDevTools } from 'redux-devtools-extension'
	import reducers from './reducers.js'
	import thunk from "redux-thunk";
	import logger from "redux-logger";
	const store = createStore(reducers, composeWithDevTools(applyMiddleware(thunk, logger)));
	export default store;		

#index.js
---------
	
	import store from './redux/store';
	import { Provider } from 'react-redux';

	const root = ReactDOM.createRoot(document.getElementById('root'));
	root.render(
	  <Provider store={store}>
	    <App />
	  </Provider>
	);
	

#app.js
-------
	
	import "./App.css"
	import { useDispatch, useSelector } from "react-redux";
	import { DELETE_DATA_ACTION, FETCH_DATA_ACTION } from "./redux/actions.js";
	const App = () => {
	  const state = useSelector(state => state);
	  const dispatch = useDispatch();
	  let data = state.post.map(item => {
	    return <tr key={item.id}>
	      <td>{item.id}</td>
	      <td>{item.title}</td>
	    </tr>
	  })


	  return (
	    <div className="App">
	      <button onClick={() => dispatch(FETCH_DATA_ACTION())}>Fetch Data</button>
	      <button onClick={() => dispatch(DELETE_DATA_ACTION())}>Delete Data</button>
	      <table border="2" cellPadding="2" cellSpacing="3" style={{ textAlign: 'center' }}>
	        <thead>
	          <tr>
	            <th>Id</th>
	            <th>title</th>
	          </tr>
	        </thead>
	        <tbody>
	          {data}
	        </tbody>
	      </table>
	    </div>
	  )
	}

	export default App;
=========================================================================================================================
@useRef
	
	1. use to acces node directly like document.querySelectory()
	2. try to aviod as mush you can beacuse its update real dom directly not the virtual dom which is quite expensive

	import './App.css'
	import { useEffect, useRef } from "react";

	const App = () => {
	  let inputRef = useRef(null);
	  useEffect(() => {
	    inputRef.current.focus();
	  })
	  return (
	    <div className="App">
	      <input type="" name='firstName' placeholder='EnterName' ref={inputRef} />
	    </div>
	  )
	}

	export default App;

=========================================================================================================================
@useCallback + React.memo
	
	1. The React useCallback Hook returns a memoized callback function.
	2. Think of memoization as caching a value so that it does not need to be recalculated.
	3. This allows us to isolate resource intensive functions so that they will not automatically run on every render.
	4. The useCallback Hook only runs when one of its dependencies update.
	5. This can improve performance.
	6. The useCallback and useMemo Hooks are similar. The main difference is that useMemo returns a memoized value and 
	useCallback returns a memoized function

	
	#React.memo help to prevent from re-rendering of component if state does not get change its not a hook its a feature

	Synatx
	------
		
		export default React.memo(componentName);

	problem : when we passing function object 
	-------

		suppose we create button component and we use it 2 times with passing two different functions eg : function1 and function2 
		from parent to child & then we click on one button the second button will re-render automatically beacuse every time 
		function create new reference when ever parent comonent re-render due to state change, so when ever we are dealing with 
		function we always have to concider reference equality even though two functions have the exact same behaviour it does not 
		means they are equal to each other so the function before re-render is different to the function after the rerender and 
		so the function is props "react.memo" sees that the props has changed and will not prevent the re-render so when click
		on first button new reference is created for other button and vice-versa sooo we can tell to react that don't create new 
		function for second button when we click on first button

	solution
	--------
		 useCallback hook 

		 #What?

		 	useCallback is a hook that will return a memoized(cache) version of the callback function that only changes if one of the
		 	dependencies has changed

		 #why?

		 	It is usefull when passing callbacks to optimized child components that rely on reference equality to prevent unneccessary 
		 	renders	

		 #how

		 	const handleEvent = () => useCallback(() => {
		 		setState(count => count + 1);
		 	},[count])	

		
#button.js 
----------
	
	import React from "react";
	const Button = (props) => {
	    console.log(props.children + 'Button Component');
	    let handleEvent = props.handleEvent;
	    let children = props.children
	    return (
	        <button onClick={handleEvent}>{children}</button>
	    )
	}

	export default React.memo(Button);

#count.js
---------
	
	import React from "react";
	const Count = ({ text, age }) => {
	    console.log(text + ' component');
	    return (
	        <div> {text} : {age}</div>
	    )
	}
	export default React.memo(Count);

#app.js
	
	import './App.css'
	import Button from './component/button';
	import Count from './component/count';
	import Title from './component/title';
	import { useCallback, useState } from 'react'


	const App = () => {
	  const [age, setage] = useState(0);
	  const [salary, setSalary] = useState(100);

	  const incerementAge = useCallback(() => {
	    setage((age) => age + 1);
	  }, [age])

	  const incerementSalary = useCallback(() => {
	    setSalary((salary) => salary + 1000);
	  }, [salary]);
	  console.log('----------------x-----------------------');
	  return (
	    <div className='App'>
	      <Title />
	      <Count text='Age' age={age} />
	      <Button handleEvent={incerementAge}> Increment Age </Button>
	      <Count text='Salary' age={salary} />
	      <Button handleEvent={incerementSalary}> Increment Salary </Button>
		</div>
	  )
	}

	export default App;				 	

=========================================================================================================================
@useMemo
	
	1. The React useMemo Hook returns a memoized value.
	2. Think of memoization as caching a value so that it does not need to be recalculated.
	3. The useMemo Hook only runs when one of its dependencies update.
	4. This can improve performance.
	5. The useMemo and useCallback Hooks are similar. The main difference is that useMemo returns a memoized value and useCallback returns a memoized function. 	

#example: 
---------

	import './App.css'
	import { useMemo, useState } from 'react'
	const App = () => {
	  const [count, setCount] = useState(0);
	  const [item, setItem] = useState(10);

	  const isEven = useMemo(() => {
	    console.log('called is even function');
	    let i = 0;
	    while (i < 2000000000) i++;
	    return count % 2 === 0;
	  }, [count])

	return (
	    <div className='App'>
	      <div><button onClick={() => setCount((count) => count + 1)}>Count - {count}</button></div>
	      <span>{isEven ? 'Even' : 'Odd'}</span>
	      <div><button onClick={() => setItem((item) => item + 1)}>Item - {item}</button></div>
	    </div>
	  )
	}

	export default App;

=========================================================================================================================
@Condition Ouput

- you can write condition directly in JSX
	
	{ condition ? <h1>Hello yes</h1> : <h1>Hello No</h1> }

- best way to put all data into variable	
	
	const  outPut = condition ? <h1>Hello yes</h1> : <h1>Hello No</h1>;

	{outPut}










=========================================================================================================================
Class Component

	
=========================================================================================================================
@concept of 'this'
	
	handleEvent() {
		this.state 			// this will not work here beacuse this behavous differently so it should be bind in constructor method
	}

solution -> 
	
	constructor() {
		this.handleEvent = this.handleEvent.bind(this)			
	}	

	or 

	with arrow function in function calling

	<button onClick={() => this.handleEvent}>Click </button>

	or 

	handleEvent = () =>  {
		this.state 			
	}

=========================================================================================================================

	